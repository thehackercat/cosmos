# 01-程序的运行过程：从代码到机器运行

December 2, 2021 2021-12-02

# 笔记

使用命令：gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld ，就可以编译这段代码。其实，GCC 只是完成编译工作的驱动程序，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作。

下图就是编译这段代码的过程：

![Untitled](01-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%BA%E5%99%A8%E8%BF%90%E8%A1%8C%20ca35acef5c474e22972867ef7f0d64e3/Untitled.png)

其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：

- gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入头文件，替换宏。
- gcc HelloWorld.c -S -c -o HelloWorld.s 编译：包含预处理，将 C 程序转换成汇编程序。
- gcc HelloWorld.c -c -o HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。
- gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。

## 思考题

为了实现 C 语言中函数的调用和返回功能，CPU 实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call 和 ret 指令在逻辑上执行的操作是怎样的呢？

## 解答

首先假设CPU执行指令是顺序执行的，那么程序的调用需要考虑几个问题:

1，call指令要执行的代码在哪？也就是被调用函数的第一条指令所在的内存地址

2，被调用函数执行完之后，返回哪个位置继续执行？

只要解决上面这两个问题，那么函数调用时指令的间的跳转就迎刃而解了。

针对第一个问题，在gcc编译完成之后，函数对应的指令序列所在的位置就已经确定了，因此这是编译阶段需要考虑的问题

至于第二个问题，在执行完call指令的同时，需要将call指令下面一条指令的地址保存到栈内存中，同时更新%rsp寄存器指向的位置，然后就可以开始执行被调函数的指令序列，执行完毕后，由ret指令从rsp中获取栈顶的returnadress地址，然后跳转到call的下一条指令继续执行。
